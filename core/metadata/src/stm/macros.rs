// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

/// Generates the state's inner struct.
///
/// # Generated items
/// - `{$state}Inner` struct with the specified fields (the data)
///
/// The wrapper struct, `From` impls, command enum, parsing, dispatch, and
/// Absorb impl are all generated by `collect_handlers!`, which knows the
/// output type.
#[macro_export]
macro_rules! define_state {
    (
        $state:ident {
            $($field_name:ident : $field_type:ty),* $(,)?
        }
    ) => {
        paste::paste! {
            #[derive(Debug, Clone, Default)]
            pub struct [<$state Inner>] {
                $(
                    pub $field_name: $field_type,
                )*
            }

            impl [<$state Inner>] {
                pub fn new() -> Self {
                    Self::default()
                }
            }
        }
    };
}

/// Generates the command enum, wrapper struct, parsing, dispatch, State, and
/// envelope-aware Absorb for a state type.
///
/// # Syntax
/// ```ignore
/// collect_handlers! { Streams { Op1, Op2 } }           // Output = ()
/// collect_handlers! { Streams -> OutputType { Op1 } }   // Output = OutputType
/// ```
///
/// # Generated items
/// - `$state` wrapper struct (contains LeftRight storage)
/// - `From<LeftRight<...>>` impl for `$state`
/// - `From<{$state}Inner>` impl for `$state`
/// - `{$state}Command` enum with one variant per operation
/// - `Command` impl for `{$state}Inner` (parses `Message<PrepareHeader>`)
/// - `{$state}Inner::dispatch()` method (routes each variant to `StateHandler::apply()`)
/// - `State` impl for `$state` wrapper
/// - `Absorb<CommandEnvelope<{$state}Command, Output>>` impl for `{$state}Inner`
///
/// # Requirements
/// Each listed operation type must implement `StateHandler<State = {$state}Inner, Output = $output>`.
#[macro_export]
macro_rules! collect_handlers {
    // Default output: ()
    (
        $state:ident {
            $($operation:ident),* $(,)?
        }
    ) => {
        $crate::__collect_handlers_impl!($state -> () { $($operation),* });
    };
    // Explicit output type
    (
        $state:ident -> $output:ty {
            $($operation:ident),* $(,)?
        }
    ) => {
        $crate::__collect_handlers_impl!($state -> $output { $($operation),* });
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! __collect_handlers_impl {
    (
        $state:ident -> $output:ty {
            $($operation:ident),*
        }
    ) => {
        paste::paste! {
            // --- wrapper struct + From impls (moved from define_state!) ---

            #[derive(Debug)]
            pub struct $state {
                inner: $crate::stm::LeftRight<
                    [<$state Inner>],
                    [<$state Command>],
                    $output,
                >,
            }

            impl From<$crate::stm::LeftRight<[<$state Inner>], [<$state Command>], $output>> for $state {
                fn from(inner: $crate::stm::LeftRight<[<$state Inner>], [<$state Command>], $output>) -> Self {
                    Self { inner }
                }
            }

            impl $state {
                pub fn with_state<F, Ret>(&self, f: F) -> Ret
                where
                    F: FnOnce(&[<$state Inner>]) -> Ret,
                {
                    self.inner.with_state(f)
                }
            }

            impl From<[<$state Inner>]> for $state {
                fn from(inner: [<$state Inner>]) -> Self {
                    let left_right: $crate::stm::LeftRight<
                        [<$state Inner>],
                        [<$state Command>],
                        $output,
                    > = inner.into();
                    left_right.into()
                }
            }

            // --- command enum ---

            #[derive(Debug, Clone)]
            pub enum [<$state Command>] {
                $(
                    $operation($operation),
                )*
            }

            // --- Command trait ---

            impl $crate::stm::Command for [<$state Inner>] {
                type Cmd = [<$state Command>];
                type Input = ::iggy_common::message::Message<::iggy_common::header::PrepareHeader>;
                type Output = $output;

                fn parse(input: Self::Input) -> Result<Self::Cmd, Self::Input> {
                    use ::iggy_common::BytesSerializable;
                    use ::iggy_common::header::Operation;

                    match input.header().operation {
                        $(
                            Operation::$operation => {
                                let body = input.body_bytes();
                                // FIXME: return a parse error instead of panicking on malformed input
                                Ok([<$state Command>]::$operation(
                                    $operation::from_bytes(body).unwrap()
                                ))
                            },
                        )*
                        _ => Err(input),
                    }
                }
            }

            // --- dispatch ---

            impl [<$state Inner>] {
                fn dispatch(&mut self, cmd: &[<$state Command>], now: ::iggy_common::IggyTimestamp) -> $output {
                    match cmd {
                        $(
                            [<$state Command>]::$operation(payload) => {
                                $crate::stm::StateHandler::apply(payload, self, now)
                            },
                        )*
                    }
                }
            }

            // --- State trait ---

            impl $crate::stm::State for $state {
                type Input = <[<$state Inner>] as $crate::stm::Command>::Input;
                type Output = $output;

                fn apply(&self, input: Self::Input) -> Result<Self::Output, Self::Input> {
                    let cmd = <[<$state Inner>] as $crate::stm::Command>::parse(input)?;
                    Ok(self.inner.do_apply(cmd))
                }
            }

            // --- Absorb<CommandEnvelope<...>> ---

            impl left_right::Absorb<$crate::stm::CommandEnvelope<[<$state Command>], $output>>
                for [<$state Inner>]
            {
                fn absorb_first(
                    &mut self,
                    envelope: &mut $crate::stm::CommandEnvelope<[<$state Command>], $output>,
                    _other: &Self,
                ) {
                    let result = self.dispatch(&envelope.cmd, envelope.now);
                    if !envelope.output.is_null() {
                        // Safety: pointer targets WriteCell::apply()'s stack local,
                        // still alive during synchronous publish().
                        unsafe { *envelope.output = Some(result) };
                        // Nullify so the stale copy in absorb_second won't write
                        // through a dangling pointer.
                        envelope.output = std::ptr::null_mut();
                    }
                }

                fn absorb_second(
                    &mut self,
                    mut envelope: $crate::stm::CommandEnvelope<[<$state Command>], $output>,
                    _other: &Self,
                ) {
                    let result = self.dispatch(&envelope.cmd, envelope.now);
                    if !envelope.output.is_null() {
                        // Safety: on the `extend` (first-publish) path, this is
                        // absorb_second and the pointer is still live.
                        unsafe { *envelope.output = Some(result) };
                        envelope.output = std::ptr::null_mut();
                    }
                }

                fn sync_with(&mut self, first: &Self) {
                    *self = first.clone();
                }
            }
        }
    };
}
